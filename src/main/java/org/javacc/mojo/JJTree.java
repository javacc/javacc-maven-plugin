/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.javacc.mojo;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.StringUtils;

/** Provides a facade for the mojos to invoke JJTree. */
class JJTree extends ToolFacade {

  /** The input grammar. */
  private File inputFile;

  /** The option OUTPUT_DIRECTORY. */
  private File outputDirectory;

  /** The option GRAMMAR_ENCODING. */
  private String grammarEncoding;

  //  /** The option JDK_VERSION. */
  //  private String jdkVersion;

  /** The option STATIC. */
  private Boolean isStatic;

  /** The option BUILD_NODE_FILES. */
  private Boolean buildNodeFiles;

  /** The option MULTI. */
  private Boolean multi;

  /** The option NODE_DIRECTOY. */
  private File nodeDirectory;

  /** The option NODE_DEFAULT_VOID. */
  private Boolean nodeDefaultVoid;

  /** The option NODE_CLASS. */
  private String nodeClass;

  /** The option NODE_FACTORY. */
  private String nodeFactory;

  /** The option NODE_PACKAGE. */
  private String nodePackage;

  /** The option NODE_PREFIX. */
  private String nodePrefix;

  /** The option NODE_SCOPE_HOOK. */
  private Boolean nodeScopeHook;

  /** The option NODE_USES_PARSER. */
  private Boolean nodeUsesParser;

  /** The option TRACK_TOKENS. */
  private Boolean trackTokens;

  /** The option VISITOR. */
  private Boolean visitor;

  /** The option VISITOR_DATA_TYPE. */
  private String visitorDataType;

  /** The option VISITOR_RETURN_TYPE. */
  private String visitorReturnType;

  /** The option VISITOR_EXCEPTION. */
  private String visitorException;

  /** The option CODE_GENERATOR. */
  private String codeGenerator;

  /** The option OUTPUT_LANGUAGE. */
  private String ouputLanguage;

  /**
   * Sets the absolute path to the grammar file to pass into JJTree for preprocessing.
   *
   * @param value The absolute path to the grammar file to pass into JJTree for preprocessing.
   */
  public void setInputFile(final File value) {
    if (value != null && !value.isAbsolute()) {
      throw new IllegalArgumentException("path is not absolute: " + value);
    }
    inputFile = value;
  }

  /**
   * Sets the absolute path to the output directory.
   *
   * @param value The absolute path to the output directory for the generated grammar file. If this
   *     directory does not exist yet, it is created. Note that this path should already include the
   *     desired package hierarchy because JJTree will not append the required sub directories
   *     automatically.
   */
  public void setOutputDirectory(final File value) {
    if (value != null && !value.isAbsolute()) {
      throw new IllegalArgumentException("path is not absolute: " + value);
    }
    outputDirectory = value;
  }

  /**
   * Gets the absolute path to the enhanced grammar file generated by JJTree.
   *
   * @return The absolute path to the enhanced grammar file generated by JJTree or <code>null</code>
   *     if either the input file or the output directory have not been set.
   */
  public File getOutputFile() {
    File outputFile = null;
    if (outputDirectory != null && inputFile != null) {
      final String fileName = FileUtils.removeExtension(inputFile.getName()) + ".jj";
      outputFile = new File(outputDirectory, fileName);
    }
    return outputFile;
  }

  /**
   * Sets the option GRAMMAR_ENCODING.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setGrammarEncoding(final String value) {
    grammarEncoding = value;
  }

  //  /**
  //   * Sets the option JDK_VERSION.
  //   *
  //   * @param value The option value, may be <code>null</code> to use the value provided in the
  //   *     grammar or the default.
  //   */
  //  public void setJdkVersion(final String value) {
  //    jdkVersion = value;
  //  }

  /**
   * Sets the option STATIC.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setStatic(final Boolean value) {
    isStatic = value;
  }

  /**
   * Sets the option value BUILD_NODE_FILES.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setBuildNodeFiles(final Boolean value) {
    buildNodeFiles = value;
  }

  /**
   * Sets the option value NODE_DIRECTORY.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodeDirectory(final File value) {
    nodeDirectory = value;
  }

  /**
   * Sets the option value MULTI.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setMulti(final Boolean value) {
    multi = value;
  }

  /**
   * Sets the option value NODE_DEFAULT_VOID.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodeDefaultVoid(final Boolean value) {
    nodeDefaultVoid = value;
  }

  /**
   * Sets the option value NODE_CLASS.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodeClass(final String value) {
    nodeClass = value;
  }

  /**
   * Sets the option value NODE_FACTORY.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodeFactory(final String value) {
    nodeFactory = value;
  }

  /**
   * Sets the option value NODE_PACKAGE.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodePackage(final String value) {
    nodePackage = value;
  }

  /**
   * Sets the option value NODE_PREFIX.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodePrefix(final String value) {
    nodePrefix = value;
  }

  /**
   * Sets the option value NODE_SCOPE_HOOK.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodeScopeHook(final Boolean value) {
    nodeScopeHook = value;
  }

  /**
   * Sets the option value NODE_USES_PARSER.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setNodeUsesParser(final Boolean value) {
    nodeUsesParser = value;
  }

  /**
   * Sets the option value TRACK_TOKENS.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setTrackTokens(final Boolean value) {
    trackTokens = value;
  }

  /**
   * Sets the option value VISITOR.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setVisitor(final Boolean value) {
    visitor = value;
  }

  /**
   * Sets the option value VISITOR_DATA_TYPE.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setVisitorDataType(final String value) {
    visitorDataType = value;
  }

  /**
   * Sets the option value VISITOR_RETURN_TYPE.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setVisitorReturnType(final String value) {
    visitorReturnType = value;
  }

  /**
   * Sets the option value VISITOR_EXCEPTION.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setVisitorException(final String value) {
    visitorException = value;
  }

  /**
   * Sets the option CODE_GENERATOR.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setCodeGenerator(final String value) {
    codeGenerator = value;
  }

  /**
   * Sets the option OUTPUT_LANGUAGE.
   *
   * @param value The option value, may be <code>null</code> to use the value provided in the
   *     grammar or the default.
   */
  public void setOutputLanguage(final String value) {
    ouputLanguage = value;
  }

  /** {@inheritDoc} */
  @Override
  protected int execute() throws Exception {
    final String[] args = generateArguments();

    if (outputDirectory != null && !outputDirectory.exists()) {
      outputDirectory.mkdirs();
    }

    final org.javacc.jjtree.JJTree jjtree = new org.javacc.jjtree.JJTree();
    return jjtree.main(args);
  }

  /**
   * Assembles the command line arguments for the invocation of JJTree according to the
   * configuration.<br>
   * <br>
   * <strong>Note:</strong> To prevent conflicts with JavaCC options that might be set directly in
   * the grammar file, only those parameters that have been explicitly set are passed on the command
   * line.
   *
   * @return A string array that represents the arguments to use for JJTree.
   */
  private String[] generateArguments() {
    final List<String> argsList = new ArrayList<String>();

    if (StringUtils.isNotEmpty(grammarEncoding)) {
      argsList.add("-GRAMMAR_ENCODING=" + grammarEncoding);
    }

    //    if (StringUtils.isNotEmpty(jdkVersion)) {
    //      argsList.add("-JDK_VERSION=" + jdkVersion);
    //    }

    if (buildNodeFiles != null) {
      argsList.add("-BUILD_NODE_FILES=" + buildNodeFiles);
    }

    if (nodeDirectory != null) {
      argsList.add("-NODE_DIRECTORY=" + nodeDirectory.getPath());
    }

    if (multi != null) {
      argsList.add("-MULTI=" + multi);
    }

    if (nodeDefaultVoid != null) {
      argsList.add("-NODE_DEFAULT_VOID=" + nodeDefaultVoid);
    }

    if (StringUtils.isNotEmpty(nodeClass)) {
      argsList.add("-NODE_CLASS=" + nodeClass);
    }

    if (StringUtils.isNotEmpty(nodeFactory)) {
      argsList.add("-NODE_FACTORY=" + nodeFactory);
    }

    if (StringUtils.isNotEmpty(nodePackage)) {
      argsList.add("-NODE_PACKAGE=" + nodePackage);
    }

    if (StringUtils.isNotEmpty(nodePrefix)) {
      argsList.add("-NODE_PREFIX=" + nodePrefix);
    }

    if (nodeScopeHook != null) {
      argsList.add("-NODE_SCOPE_HOOK=" + nodeScopeHook);
    }

    if (nodeUsesParser != null) {
      argsList.add("-NODE_USES_PARSER=" + nodeUsesParser);
    }

    if (isStatic != null) {
      argsList.add("-STATIC=" + isStatic);
    }

    if (trackTokens != null) {
      argsList.add("-TRACK_TOKENS=" + trackTokens);
    }

    if (visitor != null) {
      argsList.add("-VISITOR=" + visitor);
    }

    if (StringUtils.isNotEmpty(visitorDataType)) {
      argsList.add("-VISITOR_DATA_TYPE=" + visitorDataType);
    }

    if (StringUtils.isNotEmpty(visitorReturnType)) {
      argsList.add("-VISITOR_RETURN_TYPE=" + visitorReturnType);
    }

    if (StringUtils.isNotEmpty(visitorException)) {
      argsList.add("-VISITOR_EXCEPTION=" + visitorException);
    }

    if (StringUtils.isNotEmpty(codeGenerator)) {
      argsList.add("-CODE_GENERATOR=" + codeGenerator);
    }

    if (StringUtils.isNotEmpty(ouputLanguage)) {
      argsList.add("-OUTPUT_LANGUAGE=" + ouputLanguage);
    }

    if (outputDirectory != null) {
      argsList.add("-OUTPUT_DIRECTORY=" + outputDirectory.getAbsolutePath());
    }

    if (inputFile != null) {
      argsList.add(inputFile.getAbsolutePath());
    }

    return (String[]) argsList.toArray(new String[argsList.size()]);
  }

  /**
   * Gets a string representation of the command line arguments.
   *
   * @return A string representation of the command line arguments.
   */
  @Override
  public String toString() {
    return Arrays.asList(generateArguments()).toString();
  }
}
