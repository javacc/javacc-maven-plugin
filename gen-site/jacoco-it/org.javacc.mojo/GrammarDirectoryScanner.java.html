<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GrammarDirectoryScanner.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Integration tests coverage</a> &gt; <a href="index.source.html" class="el_package">org.javacc.mojo</a> &gt; <span class="el_source">GrammarDirectoryScanner.java</span></div><h1>GrammarDirectoryScanner.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2025-2026, Marc Mazas &lt;mazas.marc@gmail.com&gt;.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the names of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.javacc.mojo;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.maven.plugin.logging.Log;
import org.codehaus.plexus.util.DirectoryScanner;

/**
 * Scans source directories for JavaCC / JJTree / JTB grammar files, performing stale detection.
 *
 * @since 3.8.0
 * @author Maͫzͣaͬsͨ
 */
class GrammarDirectoryScanner {
  
  /** The logger. */
  private final Log log;
  
  /** The output language. */
  private final Language language;
  
  /** The grammar file encoding. */
  private final String encoding;
  
  /** The directory scanner used to scan the source directory for files. */
  private final DirectoryScanner src_ds;
  
  /** The directory scanner used to scan the target directory for files. */
  private final DirectoryScanner tgt_ds;
  
  /**
   * The array of absolute path to the output directories used to detect stale target files by
   * timestamp checking, may be &lt;code&gt;null&lt;/code&gt; if no stale detection should be performed.
   */
  private File[] outputDirectories;
  
  /**
   * The delta in milliseconds of the last modification timestamp for testing whether a grammar file
   * needs recompilation because its main generated file is stale.
   */
  private long timestampDeltaMs;
  
  /**
   * Creates a new grammar directory scanner.
   *
   * @param lg - the Log to use
   * @param lang - the Language to generate for
   * @param enc - the grammar file encoding
   */
<span class="fc" id="L81">  public GrammarDirectoryScanner(final Log lg, final Language lang, final String enc) {</span>
<span class="fc" id="L82">    log = lg;</span>
<span class="fc" id="L83">    language = lang;</span>
<span class="fc" id="L84">    encoding = enc;</span>
<span class="fc" id="L85">    src_ds = new DirectoryScanner();</span>
<span class="fc" id="L86">    src_ds.setFollowSymlinks(true);</span>
<span class="fc" id="L87">    tgt_ds = new DirectoryScanner();</span>
<span class="fc" id="L88">    tgt_ds.setFollowSymlinks(true);</span>
<span class="fc" id="L89">  }</span>
  
  /** The most recent lastModified timestamp of the dependencies jars. */
<span class="fc" id="L92">  private long jarsLastTS = 0;</span>
  
  /**
   * Setter.
   *
   * @param ts - the most recent lastModified timestamp of the dependencies jars
   */
  public void setJarsLastTS(final long ts) {
<span class="fc" id="L100">    jarsLastTS = ts;</span>
<span class="fc" id="L101">  }</span>
  
  /**
   * Setter.
   *
   * @param directories - the arrays of absolute path to the output directories used to detect stale
   *          target files by timestamp checking, should not be &lt;code&gt;null&lt;/code&gt;.
   */
  public void setOutputDirectories(final File[] directories) {
<span class="fc" id="L110">    outputDirectories = directories;</span>
<span class="fc" id="L111">  }</span>
  
  /**
   * Setter.
   *
   * @param milliseconds - the delta in milliseconds of the last modification timestamp
   */
  public void setTimestampDeltaMs(final long milliseconds) {
<span class="fc" id="L119">    timestampDeltaMs = milliseconds;</span>
<span class="fc" id="L120">  }</span>
  
  /**
   * Sets the directory scanner with its base directory.&lt;br&gt;
   * This directory must exist or the scanner will report an error.
   *
   * @param directory - the absolute path to the source directory to scan, must not be &lt;code&gt;null
   *     &lt;/code&gt;
   */
  public void dsSetBasedir(final File directory) {
<span class="fc" id="L130">    src_ds.setBasedir(directory);</span>
<span class="fc" id="L131">  }</span>
  
  /**
   * Sets the directory scanner with its inclusion pattern.
   *
   * @param includes - the set of Ant-like inclusion patterns, may be &lt;code&gt;null&lt;/code&gt; to include
   *          all files
   */
  public void dsSetIncludes(final String[] includes) {
<span class="fc" id="L140">    src_ds.setIncludes(includes);</span>
<span class="fc" id="L141">  }</span>
  
  /**
   * Sets the directory scanner with its exclusion patterns.
   *
   * @param excludes - the set of Ant-like exclusion patterns, may be &lt;code&gt;null&lt;/code&gt; to exclude
   *          no files
   */
  public void dsSetExcludes(final String[] excludes) {
<span class="fc" id="L150">    src_ds.setExcludes(excludes);</span>
<span class="fc" id="L151">    src_ds.addDefaultExcludes();</span>
<span class="fc" id="L152">  }</span>
  
  /**
   * Scans the source directory for grammar files that match at least one inclusion pattern but no
   * exclusion pattern, performing timestamp checking to include grammars that are older than the
   * dependent jars and optionally performing timestamp checking to exclude grammars whose
   * corresponding parser files are up to date.
   *
   * @param failOnGrammarError - the plugin parameter failOnGrammarError value
   * @return a list of grammar infos, may be &lt;code&gt;null&lt;/code&gt; if no grammar in the directory, and
   *         may be empty if no stale grammar found
   * @throws GrammarException if reading the grammar file failed, or if no parser name can be
   *           retrieved in the grammar
   */
  public List&lt;GrammarInfo&gt; scanForGrammars(final String failOnGrammarError)
      throws GrammarException {
    
    // here we do not catch the IllegalStateException as basedir (previously set to sourceDirectory)
    // has already (normally) be checked as not null, existing and being a directory
<span class="fc" id="L171">    src_ds.scan();</span>
<span class="fc" id="L172">    final String[] includedFiles = src_ds.getIncludedFiles();</span>
    
<span class="fc bfc" id="L174" title="All 2 branches covered.">    if (includedFiles.length == 0) {</span>
<span class="fc" id="L175">      return null;</span>
    }
    
<span class="fc" id="L178">    final List&lt;GrammarInfo&gt; includedGrammars = new ArrayList&lt;GrammarInfo&gt;();</span>
<span class="fc" id="L179">    int nbError = 0;</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    for (final String includedFile : includedFiles) {</span>
<span class="fc" id="L181">      log.debug(&quot;IncludedFile = '&quot; + includedFile + &quot;'&quot;);</span>
      
<span class="fc" id="L183">      GrammarInfo grammarInfo = null;</span>
      try {
<span class="fc" id="L185">        grammarInfo = new GrammarInfo(log, language, encoding, src_ds.getBasedir(), includedFile);</span>
      }
<span class="fc" id="L187">      catch (final GrammarException e) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (&quot;first&quot;.equals(failOnGrammarError)) {</span>
          // 'first': let it be handled above
<span class="fc" id="L190">          throw e;</span>
        } else {
          // 'last' or 'ignore': continue on next grammar
<span class="fc" id="L193">          nbError++;</span>
<span class="fc" id="L194">          log.error(e.getMessage());</span>
<span class="fc" id="L195">          log.info(</span>
              &quot;Continuing finding grammars as failOnGrammarError is set to 'last' or 'ignore'&quot;);
<span class="fc" id="L197">          continue;</span>
        }
<span class="fc" id="L199">      }</span>
<span class="fc" id="L200">      final File grammarFile = grammarInfo.getAbsoluteGrammarFile();</span>
<span class="fc" id="L201">      final long grammarTS = grammarFile.lastModified();</span>
<span class="fc" id="L202">      log.debug(</span>
          &quot;LastModified timestamp of grammar file '&quot; + grammarFile + &quot;' is '&quot; + grammarTS + &quot;'&quot;);
      
<span class="fc bfc" id="L205" title="All 2 branches covered.">      if (timestampDeltaMs &gt;= 0) {</span>
        // stale detection needed
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (final File outDir : outputDirectories) {</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">          if (includedGrammars.contains(grammarInfo)) {</span>
            // (do not to include more than once a grammar)
<span class="fc" id="L210">            break;</span>
          }
<span class="fc" id="L212">          log.debug(&quot;Getting target files on '&quot; + outDir + &quot;'&quot;);</span>
<span class="fc" id="L213">          final File[] targetFiles = getTargetFile(outDir, grammarInfo);</span>
<span class="fc bfc" id="L214" title="All 4 branches covered.">          if (targetFiles == null //</span>
              || targetFiles.length == 0) {
            // no generated file
<span class="fc" id="L217">            includedGrammars.add(grammarInfo);</span>
<span class="fc" id="L218">            log.info(</span>
                &quot;Grammar file '&quot; + grammarFile + &quot;' included as no existing main generated file&quot;);
          } else {
<span class="fc bfc" id="L221" title="All 2 branches covered.">            for (final File targetFile : targetFiles) {</span>
<span class="fc" id="L222">              final long targetTS = targetFile.lastModified();</span>
<span class="fc" id="L223">              log.debug(&quot;LastModified timestamp of main generated file '&quot; + targetFile + &quot;' is '&quot;</span>
                  + targetTS + &quot;'&quot;);
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">              if (targetTS + timestampDeltaMs &lt; grammarTS) {</span>
                // grammar file more recent than generated file
<span class="nc" id="L227">                includedGrammars.add(grammarInfo);</span>
<span class="nc" id="L228">                log.info(&quot;Grammar file '&quot; + grammarFile</span>
                    + &quot;' included as newer than main generated file '&quot; + targetFile + &quot;'&quot;);
<span class="nc" id="L230">                break;</span>
              }
<span class="fc bfc" id="L232" title="All 2 branches covered.">              if (targetTS + timestampDeltaMs &lt; jarsLastTS) {</span>
                // jar file more recent than target file
<span class="fc" id="L234">                includedGrammars.add(grammarInfo);</span>
<span class="fc" id="L235">                log.info(&quot;Grammar file'&quot; + grammarFile + &quot;' included as main generated file '&quot;</span>
                    + targetFile + &quot;' older than dependent jar(s)&quot;);
<span class="fc" id="L237">                break;</span>
              }
<span class="fc" id="L239">              log.info(&quot;Grammar file '&quot; + grammarFile + &quot;' not included&quot;);</span>
            }
          }
        }
      } else {
        // no stale detection requested
<span class="fc" id="L245">        includedGrammars.add(grammarInfo);</span>
<span class="fc" id="L246">        log.info(&quot;Grammar file '&quot; + grammarFile + &quot;' included as no stale detection requested&quot;);</span>
      }
    }
<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (nbError &gt; 0) {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">      if (&quot;last&quot;.equals(failOnGrammarError)) {</span>
<span class="fc" id="L251">        throw new GrammarException(</span>
            &quot;Grammar reading error(s) encountered (see above), scan finished and leaving execution&quot;);
      } else {
        // failOnGrammarError == 'ignore'
<span class="fc" id="L255">        log.info(&quot;Encountered &quot; + nbError</span>
            + &quot; grammar reading errors, but ignored and continuing execution&quot;);
      }
    }
    
<span class="fc" id="L260">    return includedGrammars;</span>
  }
  
  /**
   * Determines the main generated file corresponding to the specified grammar file.
   *
   * @param targetDirectory - the absolute path to the output directory for the target files, must
   *          not be &lt;code&gt;null&lt;/code&gt;
   * @param grammarInfo - the grammar info describing the grammar file, must not be &lt;code&gt;null
   *     &lt;/code&gt;
   * @return a file array with main generated file, may be &lt;code&gt;null&lt;/code&gt;, may be empty
   */
  protected File[] getTargetFile(final File targetDirectory, final GrammarInfo grammarInfo) {
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (!targetDirectory.exists()) {</span>
<span class="fc" id="L274">      log.debug(&quot;targetDirectory '&quot; + targetDirectory + &quot;' does not exist, no target file&quot;);</span>
<span class="fc" id="L275">      return null;</span>
    }
<span class="fc" id="L277">    tgt_ds.setBasedir(targetDirectory);</span>
<span class="fc" id="L278">    tgt_ds.setIncludes(new String[] {</span>
<span class="fc" id="L279">        grammarInfo.getMainGeneratedFile()</span>
    });
<span class="fc" id="L281">    tgt_ds.setExcludes(null);</span>
    // here we do not catch the IllegalStateException as targetDirectory
    // has already (normally) be checked as not null, existing and being a directory
<span class="fc" id="L284">    tgt_ds.scan();</span>
<span class="fc" id="L285">    final String[] includedFiles = tgt_ds.getIncludedFiles();</span>
    // well, we should get 0 or 1 result
<span class="fc" id="L287">    final File[] targetFiles = new File[includedFiles.length];</span>
<span class="fc" id="L288">    int k = 0;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">    for (final String includedFile : includedFiles) {</span>
<span class="fc" id="L290">      targetFiles[k] = new File(targetDirectory, includedFile);</span>
<span class="fc" id="L291">      k++;</span>
    }
<span class="fc" id="L293">    log.debug(&quot;targetFiles = '&quot; + Arrays.toString(targetFiles) + &quot;'&quot;);</span>
<span class="fc" id="L294">    return targetFiles;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span>Integration tests coverage report</div></body></html>